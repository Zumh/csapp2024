## Summary of Representing and Manipulating Information


**Integer Representations**
* Binary, decimal, and hexadecimal representation systems
* Signed and unsigned integer types
* Range of representable integers

**Integer Arithmetic**
* Addition, subtraction, multiplication, division, and remainder operations
* Overflow and underflow conditions
* Two's-complement representation
* Bitwise Boolean operations

**Floating Point**
* IEEE floating-point format
* Normalized, denormalized, special, and infinity values
* Rounding modes
* Floating-point arithmetic properties (associativity, commutativity)
* Gradual underflow and overflow

**Summary**
This chapter presents a foundational understanding of how information is represented and manipulated on a computer, focusing on binary representation and operations on integers and floating-point numbers. The principles of the IEEE floating-point format are particularly emphasized.

## 2.1 **Information Storage**

* Computers view memory as a monolithic byte array, with each byte identified by a unique virtual address.
* The virtual address space is conceptual and may be implemented using a combination of physical memory, flash memory, disk storage, special hardware, and operating system software.
* Most computers use blocks of 8 bits, called bytes, as the smallest addressable unit of memory.
* Hexadecimal notation (base 16) is convenient for describing bit patterns, with each byte value ranging from 00 to FF.
* The word size determines the number of bits used to encode pointers and thus the size of the virtual address space (up to 2^w bytes).
* Different data formats and sizes are supported for both integer and floating-point data, depending on the machine architecture and compiler.

## 2.2 **Integer Representations**

* Computers represent integers with fixed-size data types, which have ranges limited by the word size.
* Unsigned encodings use binary notation to represent non-negative numbers, with each bit representing a power of 2.
* Two's-complement encodings represent both non-negative and negative numbers, complementing the most significant bit to represent negative values.
* Converting between unsigned and two's-complement representations involves adding or subtracting a power of 2.
* Expanding or truncating the bit representation of a number may affect its value or cause overflow/underflow.

**Two's-Complement Addition**

* With two's-complement addition, the result is truncated to the word size, potentially causing overflow.
* Positive overflow occurs when the sum exceeds the maximum representable value and is corrected by subtracting 2.
* Negative overflow occurs when the sum is less than the minimum representable value and is corrected by adding 2.

**Two's-Complement Multiplication**

* Two's-complement multiplication is similar to unsigned multiplication, but the results are truncated.
* The bit-level representations of the truncated products are identical for both unsigned and two's-complement multiplication.

**Two's-Complement Negation**

* Two's-complement negation is performed by inverting the bits and adding 1.
* The bit patterns generated by two's-complement negation and unsigned negation are the same except for the most significant bit.
  
## 2.3 **Key Topics in Integer Arithmetic**

* Unsigned Addition: When adding nonnegative integers, truncation is used to ensure the sum fits within the specified word size.

* Two's-Complement Addition: Two's-complement addition is used to represent both positive and negative integers. Positive overflow occurs when the sum exceeds the maximum positive value, and is corrected by subtracting 2^w (the word size). Negative overflow occurs when the sum is less than the minimum negative value, and is corrected by adding 2^w.

* Unsigned Multiplication: Similar to unsigned addition, the product of two nonnegative integers is truncated to fit within the specified word size.

* Two's-Complement Multiplication: Two's-complement multiplication uses the same bit-level operations as unsigned multiplication. Positive overflow and negative overflow are detected in the same way as for addition.

* Division: Division of integers can be performed using arithmetic right shift, which rounds the result down. To round up, a bias is added before performing the right shift.
## 2.4 **Key Topics in Floating Point Arithmetic**

* IEEE Floating-Point Representation: Floating-point numbers are represented using a sign bit, an exponent field, and a fraction field. The exponent field determines the weight of the fraction, while the fraction field encodes the significand.

* Rounding: When a floating-point value cannot be represented exactly, it is rounded to the nearest representable value using one of four rounding modes: round-to-nearest, round-to-zero, round-to-positive-infinity, or round-to-negative-infinity.

* Floating-Point Operations: Floating-point arithmetic is not fully associative or commutative due to rounding. However, most values have additive inverses, except for infinities and NaNs.

* Special Values: Floating-point formats include special values for infinity (positive and negative) and Not-a-Number (NaN). These values are used to handle exceptional conditions, such as division by zero or the square root of a negative number.

* Comparison of Floating-Point Numbers: Floating-point numbers cannot always be compared using the standard equality operator (==) due to rounding errors. Instead, the comparison operators (<, >, <=, >=) should be used with a tolerance value to account for rounding.
